// Copyright 2022 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Combine bitwise operation and bitwise inversion.
(AND x (NOT y)) => (ANDN x y)
(OR  x (NOT y)) => (ORN  x y)
(XOR x (NOT y)) => (XNOR x y)
(NOT (XOR x y)) => (XNOR x y)

// Fold constant shift with extension.
(SRAI [c] (MOVBreg  x)) && c <   8 => (SRAI [56+c] (SLLI <typ.Int64> [56] x))
(SRAI [c] (MOVHreg  x)) && c <  16 => (SRAI [48+c] (SLLI <typ.Int64> [48] x))
(SRAI [c] (MOVWreg  x)) && c <  32 => (SRAI [32+c] (SLLI <typ.Int64> [32] x))
(SRLI [c] (MOVBUreg x)) && c <   8 => (SRLI [56+c] (SLLI <typ.UInt64> [56] x))
(SRLI [c] (MOVHUreg x)) && c <  16 => (SRLI [48+c] (SLLI <typ.UInt64> [48] x))
(SRLI [c] (MOVWUreg x)) && c <  32 => (SRLI [32+c] (SLLI <typ.UInt64> [32] x))
(SLLI [c] (MOVBUreg x)) && c <= 56 => (SRLI [56-c] (SLLI <typ.UInt64> [56] x))
(SLLI [c] (MOVHUreg x)) && c <= 48 => (SRLI [48-c] (SLLI <typ.UInt64> [48] x))
(SLLI [c] (MOVWUreg x)) && c <= 32 => (SRLI [32-c] (SLLI <typ.UInt64> [32] x))

// Shift by zero.
(SRAI [0] x) => x
(SRLI [0] x) => x
(SLLI [0] x) => x

//  "Zicond" Extension for Integer Conditional Operations
// Optimize specific patterns based on the unified OR(CZEROEQZ, CZERONEZ) form
// (x == 0) ? x : y -> CZEROEQZ y x (when x is the condition)
(OR (CZEROEQZ <t> x (SEQZ x)) (CZERONEZ <t> y (SEQZ x))) && buildcfg.GORISCV64 >= 23 => (CZEROEQZ <t> y x)

// OR-form optimizations for arithmetic/logic ops (64-bit and 32-bit)
// (z == 0) ? ((OP x y)) : x  =>  (OP x (CZERONEZ y z))
(OR (CZEROEQZ <t> ((ADD|SUB|OR|XOR|SUBW) x y) (SEQZ z)) (CZERONEZ <t> x (SEQZ z))) && buildcfg.GORISCV64 >= 23
  => ((ADD|SUB|OR|XOR|SUBW) x (CZERONEZ <t> y z))
// (z != 0) ? ((OP x y)) : x  =>  (OP x (CZEROEQZ y z))
(OR (CZEROEQZ <t> ((ADD|SUB|OR|XOR|SUBW) x y) (SNEZ z)) (CZERONEZ <t> x (SNEZ z))) && buildcfg.GORISCV64 >= 23
  => ((ADD|SUB|OR|XOR|SUBW) x (CZEROEQZ <t> y z))

// AND-specific optimizations
// (z == 0) ? (x & y) : x  =>  OR(AND x y, CZEROEQZ x z)
(OR (CZEROEQZ <t> (AND x y) (SEQZ z)) (CZERONEZ <t> x (SEQZ z))) && buildcfg.GORISCV64 >= 23
  => (OR (AND <t> x y) (CZEROEQZ <t> x z))
// (z != 0) ? (x & y) : x  =>  OR(AND x y, CZERONEZ x z)
(OR (CZEROEQZ <t> (AND x y) (SNEZ z)) (CZERONEZ <t> x (SNEZ z))) && buildcfg.GORISCV64 >= 23
  => (OR (AND <t> x y) (CZERONEZ <t> x z))

// ANDI-specific optimizations (immediate version of AND)
// (z == 0) ? (x & c) : x  =>  OR(AND x c, CZEROEQZ x z)
(OR (CZEROEQZ <t> (ANDI [c] x) (SEQZ z)) (CZERONEZ <t> x (SEQZ z))) && buildcfg.GORISCV64 >= 23
  => (OR (AND <t> x (MOVDconst [c])) (CZEROEQZ <t> x z))
// (z != 0) ? (x & c) : x  =>  OR(AND x c, CZERONEZ x z)
(OR (CZEROEQZ <t> (ANDI [c] x) (SNEZ z)) (CZERONEZ <t> x (SNEZ z))) && buildcfg.GORISCV64 >= 23
  => (OR (AND <t> x (MOVDconst [c])) (CZERONEZ <t> x z))

// Immediate variants (64-bit only) - immediate is on the right
// (z == 0) ? ((OPI [c] x)) : x  =>  (OP x (CZERONEZ c z))
(OR (CZEROEQZ <t> ((ADDI|ORI|XORI) [c] x) (SEQZ z)) (CZERONEZ <t> x (SEQZ z))) && buildcfg.GORISCV64 >= 23
  => ((ADD|OR|XOR) x (CZERONEZ <t> (MOVDconst [c]) z))
// (z != 0) ? ((OPI [c] x)) : x  =>  (OP x (CZEROEQZ c z))
(OR (CZEROEQZ <t> ((ADDI|ORI|XORI) [c] x) (SNEZ z)) (CZERONEZ <t> x (SNEZ z))) && buildcfg.GORISCV64 >= 23
  => ((ADD|OR|XOR) x (CZEROEQZ <t> (MOVDconst [c]) z))

// 32-bit immediate variant (only ADDIW exists, no SUBIW/ORIW/XORIW/ANDIW)
// (z == 0) ? (ADDIW [c] x) : x
(OR (CZEROEQZ <t> (ADDIW [c] x) (SEQZ z)) (CZERONEZ <t> x (SEQZ z))) && buildcfg.GORISCV64 >= 23
  => (ADD x (CZERONEZ <t> (MOVDconst [int64(int32(c))]) z))
// (z != 0) ? (ADDIW [c] x) : x
(OR (CZEROEQZ <t> (ADDIW [c] x) (SNEZ z)) (CZERONEZ <t> x (SNEZ z))) && buildcfg.GORISCV64 >= 23
  => (ADD x (CZEROEQZ <t> (MOVDconst [int64(int32(c))]) z))

// Optimize conditional selection of constant or zero to single CZERO instruction
// (cond == 0) ? 0 : const  =>  CZERONEZ const cond
(OR (CZEROEQZ <t> (MOVDconst [0]) (SEQZ cond)) (CZERONEZ <t> (MOVDconst [c]) (SEQZ cond))) && buildcfg.GORISCV64 >= 23
  => (CZERONEZ <t> (MOVDconst [c]) cond)
// (cond != 0) ? 0 : const  =>  CZEROEQZ const cond  
(OR (CZEROEQZ <t> (MOVDconst [0]) (SNEZ cond)) (CZERONEZ <t> (MOVDconst [c]) (SNEZ cond))) && buildcfg.GORISCV64 >= 23
  => (CZEROEQZ <t> (MOVDconst [c]) cond)

// Constant propagation through CZERO(EQ|NE)Z
(CZERO(EQ|NE)Z <t> (MOVDconst [0]) _) && buildcfg.GORISCV64 >= 23 => (MOVDconst <t> [0])